// ===============================
// Robustes TimeMoto-Skript (Final V15 - Mit Nutzer-Variable)
// ===============================

// -------------- KONFIGURATION --------------
const TARGET_EMPLOYEE = 'Alexander Bruch'; 
const TARGET_PROJECT = 'baaboo';
// -------------------------------------------

// Zeitbuchungen pro Tag: [Datum (DD-MM-YYYY), In1, Out1, In2, Out2]
const entries = [
Â  ['13-10-2025', '06:25', '12:09', '12:49', '16:17'],
Â  ['14-10-2025', '06:49', '13:59', '14:29', '18:15'],
Â  ['15-10-2025', '06:37', '13:31', '14:08', '17:27'],
Â  ['16-10-2025', '06:25', '13:33', '14:07', '17:37'],
Â  ['17-10-2025', '06:49', '13:01', '13:34', '17:23'],
Â  ['20-10-2025', '06:37', '13:43', '14:23', '18:11'],
Â  ['21-10-2025', '06:41', '13:33', '14:13', '17:43'],
Â  ['22-10-2025', '06:45', '12:55', '13:30', '17:13'],
Â  ['23-10-2025', '06:49', '12:59', '13:31', '17:43'],
Â  ['24-10-2025', '06:39', '12:21', '12:55', '17:37'],
Â  ['27-10-2025', '06:35', '12:47', '13:23', '17:21'],
Â  ['28-10-2025', '06:39', '13:01', '13:40', '17:07'],
Â  ['29-10-2025', '06:31', '13:01', '13:32', '17:17'],
Â  ['30-10-2025', '06:35', '12:41', '13:17', '16:41'],
Â  ['31-10-2025', '06:33', '12:35', '13:15', '17:17'],
];

// --- HILFSFUNKTIONEN ---

/**
 * Wartet auf ein Element im DOM oder auf eine Bedingungsfunktion (max. timeout ms).
 */
function waitFor(selectorOrFn, timeout = 8000) {
Â  return new Promise((resolve, reject) => {
Â  Â  const start = Date.now();
Â  Â  (function check() {
Â  Â  Â  let conditionMet = false;
Â  Â  Â  let result = null;

Â  Â  Â  if (typeof selectorOrFn === 'string') {
Â  Â  Â  Â  result = document.querySelector(selectorOrFn);
Â  Â  Â  Â  conditionMet = !!result;
Â  Â  Â  } else if (typeof selectorOrFn === 'function') {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  conditionMet = selectorOrFn();
Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  conditionMet = false;
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  if (conditionMet) return resolve(result);
Â  Â  Â  if (Date.now() - start > timeout) return reject(new Error(`Bedingung '${typeof selectorOrFn === 'string' ? selectorOrFn : 'Funktion'}' nicht erfÃ¼llt`));
Â  Â  Â  requestAnimationFrame(check);
Â  Â  })();
Â  });
}

/**
 * Simuliert das Tippen von Text in ein Eingabefeld.
 */
async function typeText(element, text) {
Â  if (!element) {
Â  Â  throw new Error("Element fÃ¼r typeText ist null oder undefined.");
Â  }
Â  
Â  element.focus();
Â  element.value = ''; 
Â  element.dispatchEvent(new Event('input', { bubbles: true }));
Â  element.dispatchEvent(new Event('change', { bubbles: true }));

Â  for (const char of text) {
Â  Â  element.value += char;
Â  Â  element.dispatchEvent(new Event('input', { bubbles: true }));
Â  Â  await new Promise(res => setTimeout(res, 10)); 
Â  }
Â  element.blur();
Â  element.dispatchEvent(new Event('change', { bubbles: true }));
Â  await new Promise(res => setTimeout(res, 50)); 
}

/**
 * MatSelect-Option anhand teilweisem Text auswÃ¤hlen
 */
async function selectOption(selectEl, optionText) {
Â  selectEl.click();
Â  // Feste Pause fÃ¼r das Overlay-Rendern (400ms fÃ¼r mehr StabilitÃ¤t)
Â  await new Promise(res => setTimeout(res, 400));Â 
Â  await waitFor('mat-option', 10000); 
Â Â 
Â  const opts = Array.from(document.querySelectorAll('mat-option'));
Â  const opt = opts.find(o => o.textContent.trim().toLowerCase().includes(optionText.toLowerCase()));
Â Â 
Â  if (!opt) throw new Error(`Option '${optionText}' not found`);
Â  opt.click();
}

/**
 * Ruft alle Paare (Start/Endzeit und Projekte) ab. Wichtig: NodeList muss nach DOM-Ã„nderungen neu abgerufen werden.
 */
function getClockingElements() {
    return {
        startInputs: document.querySelectorAll('input[data-cy="reporting-timereporting-clockingpair-dialog-start-time"]'),
        endInputs: document.querySelectorAll('input[data-cy="reporting-timereporting-clockingpair-dialog-end-time"]'),
        startProjectSelects: document.querySelectorAll('mat-select[data-cy="reporting-timereporting-clockingpair-dialog-start-project-select"]'),
        endProjectSelects: document.querySelectorAll('mat-select[data-cy="reporting-timereporting-clockingpair-dialog-end-project-select"]')
    };
}


// Hauptfunktion fÃ¼r einen Eintrag
async function addEntry(date, in1, out1, in2, out2) {
Â  console.log(`--- Starte Eintrag fÃ¼r ${date} ---`);
Â Â 
Â  // 1. Dialog Ã¶ffnen
Â  const addBtn = document.querySelector('[data-cy="reporting-timereporting-addclockingaction-button"]')
Â  Â  || Array.from(document.querySelectorAll('a, button')).find(el => el.textContent?.trim() === 'Add Clocking');
Â  if (!addBtn) throw new Error('Add-Clocking-Button nicht gefunden');
Â  addBtn.click();

Â  // 2. Warten, bis Dialog geÃ¶ffnet ist
Â  await waitFor('input[data-cy="reporting-addclockingactiondialog-date-input"]');

Â  // 3. Mitarbeiter setzen (falls nÃ¶tig)
Â  const empSelectSelector = 'mat-select[data-cy="reporting-addclockingactiondialog-employee-select"]';
Â  const empSelect = await waitFor(empSelectSelector, 5000);Â 

Â  // Klicke und schlieÃŸe Auswahl, um Angular-Binding zu triggern (falls nÃ¶tig)
Â  empSelect.click();
Â  await new Promise(res => setTimeout(res, 50));Â 
Â  document.body.click();Â 
Â  await new Promise(res => setTimeout(res, 100));Â 

Â  // ZusÃ¤tzliche Pause NACH dem "Wake-up"-Klick
Â  await new Promise(res => setTimeout(res, 200));Â 

Â  // PrÃ¼fen: Wenn der Name nicht sichtbar ist, auswÃ¤hlen.
Â  if (!empSelect.textContent.toLowerCase().includes(TARGET_EMPLOYEE.toLowerCase())) {
Â  Â  console.log(`Mitarbeiter (${TARGET_EMPLOYEE}) wird manuell gesetzt...`);
Â  Â  await selectOption(empSelect, TARGET_EMPLOYEE);
Â  Â  await new Promise(res => setTimeout(res, 300));Â 
Â  } else {
Â  Â  console.log(`Mitarbeiter (${TARGET_EMPLOYEE}) ist bereits korrekt voreingestellt.`);
Â  }
Â Â 
Â  // 4. Datum setzen
Â  const dateInput = document.querySelector('input[data-cy="reporting-addclockingactiondialog-date-input"]');
Â  await typeText(dateInput, date);

Â  // 5. Typ "Clock in" setzen
Â  const typeSelect = document.querySelector('mat-select[data-cy="reporting-addclockingactiondialog-status-select"]');
Â  await selectOption(typeSelect, 'Clock in');
Â  await new Promise(res => setTimeout(res, 300));Â 

Â  // 6. Startzeit (In1) setzen (im Initial-Dialog)
Â  const startInput = document.querySelector('input[data-cy="reporting-addclockingactiondialog-starttime"]');
Â  await typeText(startInput, in1);


Â  // 7. Zu "Advanced clocking settings" wechseln
Â  const advLink = [...document.querySelectorAll('a, button')].find(el => el.textContent?.trim() === 'Advanced clocking settings');
Â  if (!advLink) throw new Error('Advanced clocking settings link not gefunden');
Â  advLink.click();

Â  // 8. Warten, bis erweiterter Dialog geladen ist
Â  await waitFor('input[data-cy="reporting-timereporting-clockingpair-dialog-start-time"]');
Â Â 
Â  // Warten auf UI-StabilitÃ¤t nach dem Wechsel zum erweiterten Dialog
Â  await new Promise(res => setTimeout(res, 500));Â 

Â  // --- PROJEKT- UND ZEIT-ZUWEISUNG IN DER ERWEITERTEN ANSICHT ---
Â Â 
Â  let elements;
Â  const startInputSelector = 'input[data-cy="reporting-timereporting-clockingpair-dialog-start-time"]';
Â  const endInputSelector = 'input[data-cy="reporting-timereporting-clockingpair-dialog-end-time"]';
Â  
Â  // PAAR 1 (IN1 / OUT1)
Â  console.log("Setze Paar 1...");
Â  
Â  // 9a. Projekt 1 (Start) setzen (Element 0 muss existieren)
Â  elements = getClockingElements(); 
Â  await selectOption(elements.startProjectSelects[0], TARGET_PROJECT);

Â  // 9b. Endzeit 1 (Out1) setzen (OUT-Button klicken)
Â  console.log("FÃ¼ge Out1 hinzu...");
Â  
Â  // Warte auf StabilitÃ¤t nach dem Projekt-Select
Â  await new Promise(res => setTimeout(res, 300)); 
Â  
Â  // Finde den Out-Button der ERSTEN ZEILE
Â  const outButtonSelectorSingle = '[data-cy="reporting-timereporting-clockingpair-dialog-add-clock-out-button"]';
Â  const outButton = await waitFor(outButtonSelectorSingle);
Â  
Â  const endInputsCount = document.querySelectorAll(endInputSelector).length;
Â  outButton.click();
Â  
Â  // Warte, bis das End Time Feld erscheint
Â  await waitFor(() => document.querySelectorAll(endInputSelector).length > endInputsCount, 5000);

Â  // Selektoren neu abrufen, da die OUT-Felder jetzt im DOM sind
Â  elements = getClockingElements(); 
Â  
Â  // 9c. Endzeit 1 (Out1) setzen (Index 0)
Â  await typeText(elements.endInputs[0], out1);

Â  // 9d. Projekt 1 (Ende) setzen (Index 0)
Â  await selectOption(elements.endProjectSelects[0], TARGET_PROJECT);
Â  
Â  // PAAR 2 (IN2 / OUT2)
Â  console.log("FÃ¼ge Paar 2 hinzu...");
Â Â 
Â  // 10a. Zweites In (In2) HINZUFÃœGEN (Ã¼ber den "In" Button ganz unten)
Â  const inButtonSelector = '[data-cy="reporting-timereporting-clockingpair-dialog-add-clock-in-button"]';
Â  const inButton = await waitFor(inButtonSelector);Â 
Â  
Â  // Elemente erneut abrufen vor dem Klick
Â  elements = getClockingElements();
Â  const initialCount = elements.startInputs.length;
Â  
Â  inButton.click();
Â  
Â  // Warte, bis der zweite IN-Block im DOM erscheint
Â  await waitFor(() => document.querySelectorAll(startInputSelector).length > initialCount, 5000);
Â  
Â  // Elemente erneut abrufen, um die neuen Indexe zu erfassen
Â  elements = getClockingElements();

Â  // 10b. Startzeit 2 (In2) setzen (Index 1)
Â  await typeText(elements.startInputs[1], in2);
Â  
Â  // 10c. Projekt 2 (Start) setzen (Index 1)
Â  await selectOption(elements.startProjectSelects[1], TARGET_PROJECT);
Â  
Â  // 10d. Zweites Out (Out2) HINZUFÃœGEN (Ã¼ber den "Out" Button)
Â  // Warte auf StabilitÃ¤t nach dem Projekt-Select
Â  await new Promise(res => setTimeout(res, 300)); 
Â  
Â  // HIER IST DIE KRITISCHE STELLE: Wir suchen den EINZIGEN Out-Button, der jetzt fÃ¼r Paar 2 da ist.
Â  const outButtonSelector = '[data-cy="reporting-timereporting-clockingpair-dialog-add-clock-out-button"]';
Â  const outButton2 = await waitFor(outButtonSelector); // Sollte den Button fÃ¼r Paar 2 finden
Â  
Â  const endInputsCount2 = elements.endInputs.length;
Â  outButton2.click(); // Klicke den Button

Â  // Warte, bis End Time 2 erscheint
Â  await waitFor(() => document.querySelectorAll(endInputSelector).length > endInputsCount2, 5000);

Â  // Elemente erneut abrufen
Â  elements = getClockingElements();

Â  // 10e. Endzeit 2 (Out2) setzen (Index 1)
Â  await typeText(elements.endInputs[1], out2);

Â  // 10f. Projekt 2 (Ende) setzen (Index 1)
Â  await selectOption(elements.endProjectSelects[1], TARGET_PROJECT);


Â  // 11. Speichern
Â  const saveBtn = document.querySelector('button[data-cy="reporting-timereporting-clockingpair-dialog-editPresence-button"]');
Â  if (!saveBtn) throw new Error('Speichern-Button im erweiterten Dialog nicht gefunden');
Â  saveBtn.click();

Â  // 12. Warte auf Speicherung (PAUSE AUF 15 SEKUNDEN)
Â  await new Promise(res => setTimeout(res, 15000));Â 
}

// Sequentially add all entries
async function run() {
Â  for (const [date, in1, out1, in2, out2] of entries) {
Â  Â  console.log(`FÃ¼ge ${date} ein...`);
Â  Â  try {
Â  Â  Â  await addEntry(date, in1, out1, in2, out2);
Â  Â  Â  console.log(`Eintrag fÃ¼r ${date} erfolgreich.`);
Â  Â  } catch (error) {
Â  Â  Â  console.error(`ðŸš¨ Fehler beim EinfÃ¼gen von ${date}:`, error.message);
Â  Â  Â  break; // Stoppe bei Fehler
Â  Â  }
Â  }
Â  console.log('âœ… Alle verbleibenden EintrÃ¤ge eingetragen (oder nach Fehler gestoppt).');
}

run().catch(err => console.error('ðŸ”´ Kritischer Skriptfehler (vor Start oder im Run-Loop):', err));
